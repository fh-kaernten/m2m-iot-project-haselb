/**
 * @file i2c_master.c
 * @date 2015-06-20
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 */
/**
 * @cond
 ***********************************************************************************************************************
 * I2C_MASTER v4.1.4 Configures USIC channel to transmit & receive data using I2C protocol.
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version<br>
 *
 * 2015-06-10:
 *     - AbortTransmit and AbortReceive API return type modified. <br>
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include "i2c_master.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define FIFO_MIN(a,b)  (((a) < (b))?(a):(b))

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/

static void I2C_MASTER_lSendStart_Or_RepeatedStart(I2C_MASTER_t * handle, const uint32_t address,
		                                           const XMC_I2C_CH_CMD_t cmd);
static void I2C_MASTER_lSendStop_JumpTo_RxCallback(I2C_MASTER_t *const handle);
static void I2C_MASTER_lSendStop_JumpTo_TxCallback(I2C_MASTER_t *const handle);

static void I2C_MASTER_ReconfigureRxFIFO(const I2C_MASTER_t * const handle, uint32_t data_size);

static void I2C_MASTER_lReceive_FIFOData(I2C_MASTER_t * const handle, bool send_start, const uint32_t address,
                                         const uint32_t count);

static void I2C_MASTER_lReceive_StdData(I2C_MASTER_t * const handle, bool send_start, const uint32_t address);

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/

/*
 * @brief API to retrieve the version of the I2C_MASTER APP.
 *
 * @return DAVE_APP_VERSION_t Structure containing major version, minor version
 *         and patch version.
 */
DAVE_APP_VERSION_t I2C_MASTER_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = I2C_MASTER_MAJOR_VERSION;
  version.minor = I2C_MASTER_MINOR_VERSION;
  version.patch = I2C_MASTER_PATCH_VERSION;

  return (version);
}

/* Function to initialize the USIC Channel with GUI configured values.*/
I2C_MASTER_STATUS_t I2C_MASTER_Init(const I2C_MASTER_t *const handle)
{
  I2C_MASTER_STATUS_t status;

  if (handle != NULL)
  {
    #if (UC_FAMILY == XMC4)
      status = (I2C_MASTER_STATUS_t)CPU_CTRL_XMC4_Init(CPU_CTRL_HANDLE);
    #else
      status = (I2C_MASTER_STATUS_t)CPU_CTRL_XMC1_Init(CPU_CTRL_HANDLE);
    #endif
    if (status == I2C_MASTER_STATUS_SUCCESS)
    {
      /*Initialize the multiplexers required for I2C_MASTER configuration*/
      handle->config->fptr_i2c_config();

      status = I2C_MASTER_STATUS_SUCCESS;
    }
  }
  else
  {
    status = I2C_MASTER_STATUS_FAILURE;
  }

  return (status);
}

/* Function to get flag status of the requested parameter */
uint32_t I2C_MASTER_GetFlagStatus(const I2C_MASTER_t *handle, uint32_t flagtype)
{
  uint32_t status;

  status = XMC_I2C_CH_GetStatusFlag(handle->channel);

  return (status & flagtype);
}

/* Function to clear flag status of the requested parameter */
void I2C_MASTER_ClearFlag(const I2C_MASTER_t *handle, uint32_t flagtype)
{
  XMC_I2C_CH_ClearStatusFlag(handle->channel,flagtype);
}

/* Function to transmit the data to slave device */
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{

  I2C_MASTER_STATUS_t status = I2C_MASTER_STATUS_BUSY;

  I2C_MASTER_RUNTIME_t * ptr_runtime;

  ptr_runtime = handle->runtime;

  /* If send_stop is set to TRUE, bus_acquired flag is set to FALSE.
     If send_start is set to FALSE and bus_acquired is set to FALSE then API will return an error. */
  if (((send_start == false) && (ptr_runtime->bus_acquired == false)) || (data == NULL) || (size == 0))
  {
    status = I2C_MASTER_STATUS_FAILURE;
  }
  /* If send_start is set to TRUE, and if the bus has been acquired then bus_acquired flag is set to TRUE,
     in this case a repeated start condition is generated otherwise a start condition is generated.
     If a start condition is generated( bus_acquired was FALSE), then the bus_acquired flag is set to TRUE. */
  else
  {
    ptr_runtime->direction = (uint32_t)I2C_MASTER_DIRECTION_TRANSMIT;

    if (ptr_runtime->tx_busy == false)
    {
      /*If there is no transmission in progress, obtain the address of data, size of data*/
      ptr_runtime->tx_data = data;
      ptr_runtime->tx_data_count = size;

      /*Initialize to first index and set the busy flag*/
      ptr_runtime->tx_data_index = 0U;
      ptr_runtime->tx_busy = true;
      ptr_runtime->send_stop = send_stop;

      /* Enable ACK event */
      XMC_I2C_CH_EnableEvent(handle->channel, (uint32_t)XMC_I2C_CH_EVENT_ACK);
      XMC_I2C_CH_SetInterruptNodePointer(handle->channel,ptr_runtime->tx_ack_sr);

      if (send_start == true)
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, address, (XMC_I2C_CH_CMD_t)XMC_I2C_CH_CMD_WRITE);
      }
      else
      {
        /*Trigger the Ack interrupt*/
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)ptr_runtime->tx_ack_sr);
      }
      status = I2C_MASTER_STATUS_SUCCESS;
    } /* end of else */
  }
  return (status);
} /* end of function */

/*
 * Transmit interrupt handler for the APP.
 * This is a common interrupt handling function called for different instances of the APP.
 *
 *  @param  handle I2C_MASTER APP handle pointer of type I2C_MASTER_t*
 *
 *  @return void
 */
void I2C_MASTER_TransmitHandler(I2C_MASTER_t * const handle)
{
  I2C_MASTER_RUNTIME_t * ptr_runtime;
  uint8_t fifo_min = 0U;

  ptr_runtime = handle->runtime;

  /* check if any error flag is set */
  if (I2C_MASTER_GetFlagStatus(handle, ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
                                        (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
                                        (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR)))
  {
    /* Disable the transmit events */
    XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
    XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
    I2C_MASTER_ProtocolHandler(handle);
  }
  else
  {
/******************************************************************************************
  Direction = Transmit, Tx FIFO enabled
*******************************************************************************************/
  if (ptr_runtime->direction == (uint32_t)I2C_MASTER_DIRECTION_TRANSMIT)
  {
    if (handle->config->txFIFO_size > 0U)
    {
      if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
      {
        /*Fill the transmit FIFO */
        while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
        {
          /* transmit each byte till index reaches to the last byte */
          if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
          {
            /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
            XMC_I2C_CH_MasterTransmit(handle->channel, (uint8_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
            ptr_runtime->tx_data_index++;
          }
          else
          {
            break;
          }
        } /* end of while */
      }

      /*make sure data is transmitted in FIFO*/
      while (!XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel)){}

      /* if index is reached to last byte and "bus acquired" flag is set to true, then issue Send Stop */
      if (ptr_runtime->tx_data_index == ptr_runtime->tx_data_count)
      {
        if(ptr_runtime->bus_acquired == true)
        {
          I2C_MASTER_lSendStop_JumpTo_TxCallback(handle);
        }
      }
    } /* end of  if(handle->config->txFIFO_size > 0) */
/******************************************************************************************
    Direction = transmit and Tx FIFO disabled
*******************************************************************************************/
    else
    {
      /* transmit each byte till the last byte */
      if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
      {
        XMC_I2C_CH_MasterTransmit(handle->channel, ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
        ptr_runtime->tx_data_index++;
      }
      else
      {
        /* if index reaches last byte and bus_acquired flag is set to true, issue send stop */
        if (ptr_runtime->bus_acquired == true)
        {
          I2C_MASTER_lSendStop_JumpTo_TxCallback(handle);
        }
      }
    }
  } /* end of if(ptr_runtime->direction == (uint32_t)I2C_MASTER_DIRECTION_TRANSMIT) */
  else
  {
/**************************************************************************************************
  Direction = Receive, Tx, Rx FIFO enabled.
  Minimum FIFO value is calculated by comparing Tx FIFO and Rx FIFO size.
  If Rx FIFO is not enabled, default size of 2 is considered.
***************************************************************************************************/
    if (handle->config->txFIFO_size > 0U)
    {
      if ((handle->config->rxFIFO_size > 0U))
      {
        fifo_min = FIFO_MIN((uint32_t)(0x01U << handle->config->txFIFO_size),
                            (uint32_t)(0x01U << handle->config->rxFIFO_size));
      }
      else
      {
        /* if Rx FIFO is disabled */
        fifo_min = 2U;
      }

      XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);

      /* fill the FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
        {
          /* check for last byte and send_nack is set to true */
          if (((ptr_runtime->tx_data_index + 1) == ptr_runtime->tx_data_count) &&
               (ptr_runtime->send_nack == true))
          {
            XMC_I2C_CH_MasterReceiveNack(handle->channel);
          }
          else
          {
            XMC_I2C_CH_MasterReceiveAck(handle->channel);
          }
          ptr_runtime->tx_data_index++;

          /*if index reaches fifo size - break*/
          if ((ptr_runtime->tx_data_index) >= fifo_min)
          {
            break;
          }
        }
        else
        {
          break;
        }
      } /* end of while */
    } /* end of if(handle->config->txFIFO_size > 0) */
/**************************************************************************************************
   Direction = Receive, Tx FIFO disabled
 ***************************************************************************************************/
    else
    {
      XMC_USIC_CH_DisableEvent(handle->channel,XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);

      /* check for last byte and send_nack is set to true */
      if (((ptr_runtime->tx_data_index + 1) == ptr_runtime->tx_data_count) && (ptr_runtime->send_nack == true))
      {
        XMC_I2C_CH_MasterReceiveNack(handle->channel);
      }
      else
      {
        XMC_I2C_CH_MasterReceiveAck(handle->channel);
      }
      ptr_runtime->tx_data_index++;
    }

/**************************************************************************************************
   If last byte, then disable ACK event
 ***************************************************************************************************/
     if (handle->runtime->tx_data_index == handle->runtime->tx_data_count)
     {
       XMC_I2C_CH_DisableEvent(handle->channel,(uint32_t)XMC_I2C_CH_EVENT_ACK);
     }
  } /* end of else */
 } /* end of else */
}

/* Function to issue Send Stop command and jump to callback routine */
static void I2C_MASTER_lSendStop_JumpTo_TxCallback(I2C_MASTER_t *const handle)
{
  I2C_MASTER_RUNTIME_t * ptr_runtime;

  ptr_runtime = handle->runtime;

  XMC_I2C_CH_DisableEvent(handle->channel,((uint32_t)XMC_I2C_CH_EVENT_ACK ));

  if (ptr_runtime->send_stop == true)
  {
    ptr_runtime->bus_acquired = false;
    XMC_I2C_CH_MasterStop(handle->channel);
  }

  while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY){}

  /*All data is transmitted*/
  ptr_runtime->tx_busy = false;

  if (handle->config->tx_cbhandler != NULL)
  {
    /*Execute the 'End of transmission' callback function*/
    handle->config->tx_cbhandler();
  }
}

/*******************************************************************************
 * @brief This function registers the receive request by configuring the I2C_MASTER
 * receive FIFO/Standard buffer (depending on the user configuration). The data
 * is received asynchronously. When the requested number of data bytes are received,
 * optionally, the user configured callback function will be executed. If a callback
 * function is not configured on the APP UI, the user has to poll for the status of
 * rx_busy variable of the APP handle structure.
 *
 * Note: In FIFO mode, FIFO trigger limit should be adjusted manually to
 * read required amount of data from FIFO buffer.
 *
 *
 * @param  I2C_MASTER_t* I2C_MASTER APP handle pointer of type I2C_MASTER_t
 * @param  bool      flag for send_start
 * @param  uint32_t  slave address
 * @param  uint8_t*  Pointer to data array
 * @param  uint32_t  Total no of bytes to be read.
 * @param  bool      flag for send_stop
 * @param  bool      flag for send_nack
 *
 * @return  I2C_MASTER_STATUS_t I2C_MASTER_STATUS_SUCCESS if the request is accepted.
 *                              I2C_MASTER_STATUS_BUSY if a reception is in progress.
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 *
 ******************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                       uint8_t * data, const uint32_t count, bool send_stop, bool send_nack)
{

  I2C_MASTER_STATUS_t status = I2C_MASTER_STATUS_BUSY;
  I2C_MASTER_RUNTIME_t * ptr_runtime;

  ptr_runtime = handle->runtime;

  if (((handle == NULL) || ((send_start == false) && (ptr_runtime->bus_acquired == false)) || (data == NULL) ||
       (count == 0)))
  {
    status = I2C_MASTER_STATUS_FAILURE;
  }
  else
  {
     if (ptr_runtime->rx_busy == false)
     {
       ptr_runtime->direction = (uint32_t)I2C_MASTER_DIRECTION_RECEIVE;

       /*If no active reception in progress, obtain the address of data buffer and
         number of data bytes to be received*/
       ptr_runtime->rx_data = data;
       ptr_runtime->rx_data_count = count;
       ptr_runtime->tx_data = data;
       ptr_runtime->tx_data_count = count;
       ptr_runtime->tx_busy = true;
       ptr_runtime->rx_busy = true;
       ptr_runtime->send_stop = send_stop;
       ptr_runtime->send_nack = send_nack;
       ptr_runtime->rx_data_index = 0U;
       ptr_runtime->tx_data_index = 0U;

       if (handle->config->rxFIFO_size > 0U)
       {
         I2C_MASTER_lReceive_FIFOData(handle, send_start, address, count);
       }
       else
       {
         I2C_MASTER_lReceive_StdData(handle, send_start, address);
       }
     
       status = I2C_MASTER_STATUS_SUCCESS;
     }
  }
  return (status);
}

/**************************************************************************************************
     Rx FIFO data
***************************************************************************************************/
static void I2C_MASTER_lReceive_FIFOData(I2C_MASTER_t * const handle, bool send_start,
                                         const uint32_t address, const uint32_t count)
{
  I2C_MASTER_RUNTIME_t * ptr_runtime;

  ptr_runtime = handle->runtime;

  /*Clear the receive FIFO, configure the trigger lime
   * and enable the receive events*/
  XMC_USIC_CH_RXFIFO_Flush(handle->channel);

  /*Configure the FIFO trigger limit based on the required data size*/
  I2C_MASTER_ReconfigureRxFIFO(handle, count);

  XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel,
                                (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
                                (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
  if (send_start == true)
  {
    XMC_I2C_CH_EnableEvent(handle->channel, (uint32_t)XMC_I2C_CH_EVENT_ACK);
    XMC_I2C_CH_SetInterruptNodePointer(handle->channel,ptr_runtime->tx_ack_sr);
    I2C_MASTER_lSendStart_Or_RepeatedStart(handle,address, (XMC_I2C_CH_CMD_t)XMC_I2C_CH_CMD_READ);
  }
  else
  {
    /* if Tx FIFO enabled */
    if (handle->config->txFIFO_size > 0U)
    {
      XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,
                                     (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
        {
          if (((ptr_runtime->tx_data_index+1) == ptr_runtime->tx_data_count) &&
               (ptr_runtime->send_nack == true))
          {
            XMC_I2C_CH_MasterReceiveNack(handle->channel);
          }
          else
          {
            XMC_I2C_CH_MasterReceiveAck(handle->channel);
          }
          ptr_runtime->tx_data_index++;
        }
        else
        {
          break;
        }
      } /* end of while */
    }
    else  /* Tx FIFO disabled and Rx FIFO enabled */
    {
      XMC_USIC_CH_DisableEvent(handle->channel,XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);

      if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
      {
        if (((ptr_runtime->tx_data_index + 1) == ptr_runtime->tx_data_count) &&
             (ptr_runtime->send_nack == true))
        {
          XMC_I2C_CH_MasterReceiveNack(handle->channel);
        }
        else
        {
          XMC_I2C_CH_MasterReceiveAck(handle->channel);
        }
        ptr_runtime->tx_data_index++;
      }
    } /* end of else */
   } /* end of  if(send_start == false) */
}
/**************************************************************************************************
    Standard receive mode
***************************************************************************************************/
static void I2C_MASTER_lReceive_StdData(I2C_MASTER_t * const handle, bool send_start, const uint32_t address)
{
  I2C_MASTER_RUNTIME_t * ptr_runtime;

  ptr_runtime = handle->runtime;
   
  XMC_USIC_CH_EnableEvent(handle->channel,
                         (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE |
                         (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));

  if (send_start == true)
  {
    XMC_I2C_CH_EnableEvent(handle->channel, (uint32_t)XMC_I2C_CH_EVENT_ACK);
    XMC_I2C_CH_SetInterruptNodePointer(handle->channel,ptr_runtime->tx_ack_sr);
    I2C_MASTER_lSendStart_Or_RepeatedStart(handle, address, (XMC_I2C_CH_CMD_t)XMC_I2C_CH_CMD_READ);
  }
  else
  {
/**************************************************************************************************
     send_start flag is set to false and Tx FIFO is disabled
***************************************************************************************************/
    if (handle->config->txFIFO_size == 0U)
    {
      XMC_USIC_CH_DisableEvent(handle->channel,XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
      if (((ptr_runtime->tx_data_index + 1) == ptr_runtime->tx_data_count) && (ptr_runtime->send_nack == true))
      {
        XMC_I2C_CH_MasterReceiveNack(handle->channel);
      }
      else
      {
        XMC_I2C_CH_MasterReceiveAck(handle->channel);
      }

      ptr_runtime->tx_data_index++;
    }
/**************************************************************************************************
     send_start flag is set to false and Tx FIFO is enabled
***************************************************************************************************/
    else
    {
      XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);

      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
        {
          if (((ptr_runtime->tx_data_index + 1) == ptr_runtime->tx_data_count) &&
               (ptr_runtime->send_nack == true))
          {
            XMC_I2C_CH_MasterReceiveNack(handle->channel);
          }
          else
          {
            XMC_I2C_CH_MasterReceiveAck(handle->channel);
          }
          ptr_runtime->tx_data_index++;
        }
        else
        {
          break;
        }
      } /* end of while */
    } /* end of else */
  } /* end of else */
} /* end of function */

/* Function to issue Send Start/Repeated Start command */
static void I2C_MASTER_lSendStart_Or_RepeatedStart(I2C_MASTER_t * handle,const uint32_t address,
		                                           const XMC_I2C_CH_CMD_t cmd)
{
  if (handle->runtime->bus_acquired == true)
  {
    XMC_I2C_CH_MasterRepeatedStart(handle->channel, (uint16_t)address, cmd);
  }
  else
  {
    handle->runtime->bus_acquired = true;
    XMC_I2C_CH_MasterStart(handle->channel, (uint16_t)address, cmd);
  }
}

/*
 * Receive interrupt handler for the APP.
 * This is a common interrupt handling function for different instances of the I2C_MASTER APP.
 *
 * @param  handle I2C_MASTER APP handle pointer of type I2C_MASTER_t*
 *
 * @return void
 */
void I2C_MASTER_ReceiveHandler(I2C_MASTER_t * const handle)
{
  I2C_MASTER_RUNTIME_t * ptr_runtime;
  uint8_t fifo_lindex = 0;
  uint8_t fifo_min;

  ptr_runtime = handle->runtime;

  if (ptr_runtime->rx_busy == true)
  {
    if (handle->config->rxFIFO_size > 0)
    {
      /**************************************************************************************************
       Rx FIFO enabled
      ***************************************************************************************************/
      while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
      {
        /*Read all the content of Receive FIFO */
        ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_I2C_CH_GetReceivedData(handle->channel);
        ptr_runtime->rx_data_index++;

        if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
        {
          /*Reception complete*/
          ptr_runtime->rx_busy = false;

            /*Disable both standard receive and alternative receive FIFO events*/
            XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
                                          (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
                                                     (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));

          break;
        }
      } /* end of while(XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)*/

      /*Set the trigger limit if data still to be received*/
      if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
      {
        I2C_MASTER_ReconfigureRxFIFO(handle,(uint32_t)(ptr_runtime->rx_data_count - ptr_runtime->rx_data_index));

        if ((handle->config->txFIFO_size > 0U))
        {
          fifo_min = FIFO_MIN((uint32_t)(0x01U << handle->config->txFIFO_size),
                              (uint32_t)(0x01U << handle->config->rxFIFO_size));
       }
       else
       {
          fifo_min = 2U;
       }
       /**************************************************************************************************
         Rx and Tx FIFO enabled
        ***************************************************************************************************/
        if (handle->config->txFIFO_size > 0U)
        {
          /*Fill the transmit FIFO */
          while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
          {
            if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
            {
              if (((ptr_runtime->tx_data_index+1) == ptr_runtime->tx_data_count) &&
                   (ptr_runtime->send_nack == true))
              {
                XMC_I2C_CH_MasterReceiveNack(handle->channel);
              }
              else
              {
                XMC_I2C_CH_MasterReceiveAck(handle->channel);
              }
              ptr_runtime->tx_data_index++;

              /*if fifo size- break*/
              if ((++fifo_lindex) >= fifo_min)
              {
                fifo_lindex = 0U;
                break;
              }
            }/* end of if(handle->runtime->tx_data_index < handle->runtime->tx_data_count) */
            else
            {
              break;
            }
         }
       } /* end of  if((handle->config->txFIFO_size > 0)) */
       /**************************************************************************************************
          Rx FIFO is enabled, Tx FIFO disabled
       ***************************************************************************************************/
       else
       {
         if (((ptr_runtime->tx_data_index+1) == ptr_runtime->tx_data_count) &&
              (ptr_runtime->send_nack == true))
         {
           XMC_I2C_CH_MasterReceiveNack(handle->channel);
         }
         else
         {
           XMC_I2C_CH_MasterReceiveAck(handle->channel);
         }

         ptr_runtime->tx_data_index++;
       }
     } /* end of if(ptr_runtime->rx_data_index < ptr_runtime->rx_data_count) */
      /**************************************************************************************************
        if last byte to receive then disable receive events and jump to callback routine
      ***************************************************************************************************/
     if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
     {
       /*Clear both standard receive and alternative receive FIFO events*/
       XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
                                      (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
                                      (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));

       /*Disable both standard receive and alternative receive events*/
       XMC_USIC_CH_DisableEvent(handle->channel,
                                  (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE |
                                  (uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE));

       if (ptr_runtime->bus_acquired == true)
       {
         I2C_MASTER_lSendStop_JumpTo_RxCallback(handle);
       }
     }
    } /*  end of if(handle->config->rxFIFO_size > 0) */
/**************************************************************************************************
     Rx FIFO disabled
***************************************************************************************************/
    else
    {
      ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_I2C_CH_GetReceivedData(handle->channel);
      ptr_runtime->rx_data_index++;

      if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
        {
          /* if receive byte is end of byte and send_nack is true, send to receive Nack otherwise Ack*/
          if (((ptr_runtime->tx_data_index) == (ptr_runtime->tx_data_count - 1)) && (ptr_runtime->send_nack == true))
          {
            XMC_I2C_CH_MasterReceiveNack(handle->channel);
          }
          else
          {
            XMC_I2C_CH_MasterReceiveAck(handle->channel);
          }

          ptr_runtime->tx_data_index++;
        }
      }
      else
      {
        /*Disable both standard receive and alternative receive events*/
        XMC_USIC_CH_DisableEvent(handle->channel,
                                      (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE |
                                      (uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE));
        if (ptr_runtime->bus_acquired == true)
        {
          I2C_MASTER_lSendStop_JumpTo_RxCallback(handle);
        }
      }
    }
  } /* end of  if(ptr_runtime->rx_busy == true)*/
}

/* Function to issue Send Stop command and jump to receive callback routine */
static void I2C_MASTER_lSendStop_JumpTo_RxCallback(I2C_MASTER_t *const handle)
{
    I2C_MASTER_RUNTIME_t * ptr_runtime;

    ptr_runtime = handle->runtime;

    if (ptr_runtime->send_stop == true)
    {
      ptr_runtime->bus_acquired = false;
      XMC_I2C_CH_MasterStop(handle->channel);
    }

    while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY){}

    /*Reception complete*/
    ptr_runtime->rx_busy = false;
    ptr_runtime->tx_busy = false;

    if (handle->config->rx_cbhandler != NULL)
    {
      /*Execute the 'End of reception' callback function*/
      handle->config->rx_cbhandler();
    }
}

/*
 * Protocol interrupt handling function.
 * The function is common for different instances of the I2C_MASTER APP.
 *
 * @param  handle I2C_MASTER APP handle pointer of type I2C_MASTER_t*
 *
 * @return void
 */
void I2C_MASTER_ProtocolHandler(I2C_MASTER_t * const handle)
{
  uint32_t psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);

  /*Check for nack event*/
  if ((handle->config->nack_cbhandler != NULL) && (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED))
  {
    I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED);
    handle->config->nack_cbhandler();
  }

  /*Check for arbitration lost*/
  if ((handle->config->arbitration_cbhandler != NULL) && (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST))
  {
    I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST);
    handle->config->arbitration_cbhandler();
  }

  /*Check for error detected*/
  if ((handle->config->error_cbhandler != NULL) && (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR))
  {
    I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR);
    handle->config->error_cbhandler();
  }
}

/*
 * @brief A local function to reconfigure Receive FIFO with the given size and trigger limit.
 * Size is needed because the FIFO should be disabled before changing the trigger limit by
 * clearing the FIFO size.
 *
 * @param I2C_MASTER_t * pointer to the I2C_MASTER APP handle
 * @param uint32_t  number of bytes to be received.
 *
 * @return void.
 */

static void I2C_MASTER_ReconfigureRxFIFO(const I2C_MASTER_t * const handle, uint32_t data_size)
{
  uint8_t tx_fifo_size;
  uint8_t rx_fifo_size;
  uint8_t fifo_limit;

  rx_fifo_size = (0x01U << handle->config->rxFIFO_size);

  if ((handle->config->txFIFO_size > 0))
  {
    tx_fifo_size = (0x01U << handle->config->txFIFO_size);
  }
  else
  {
    tx_fifo_size = 1;
  }

  fifo_limit = FIFO_MIN(data_size,FIFO_MIN(tx_fifo_size,rx_fifo_size));

  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->rxFIFO_size, (uint8_t)(fifo_limit - 1));
}

/*******************************************************************************
 * @brief Aborts the ongoing data transmission.
 * @param I2C_MASTER_t*  I2C_MASTER APP handle pointer of type I2C_MASTER_t
 * @return I2C_MASTER_STATUS_t
 *
 * Details of function:
 * If there is a transmission in progress, it will be stopped. If transmit FIFO is used,
 * the existing data will be flushed. After the transmission is stopped, user can start
 * a new transmission without delay.
 ******************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_AbortTransmit(const I2C_MASTER_t *const handle)
{
    handle->runtime->tx_busy = false;
    handle->runtime->tx_data = NULL;
    handle->runtime->bus_acquired = false;

    /*Disable the transmit interrupts*/
    if (handle->config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*Disable the transmit FIFO event*/
      XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
      XMC_USIC_CH_TXFIFO_Flush(handle->channel);
    }
    else
    {
      /*Disable the standard transmit event*/
      XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
    }
    XMC_I2C_CH_DisableEvent(handle->channel,((uint32_t)XMC_I2C_CH_EVENT_ACK ));
	
	return(I2C_MASTER_STATUS_SUCCESS);	
}

/*******************************************************************************
 * @brief Aborts the ongoing data reception.
 * @param I2C_MASTER_t* I2C_MASTER APP handle pointer of type I2C_MASTER_t
 * @return I2C_MASTER_STATUS_t
 *
 * Details of function:
 * If a reception is in progress, it will be stopped. When a reception request
 * is active, user will not be able to place a new receive request till the active
 * reception is complete. This API can stop the progressing reception to make
 * a new receive request.
 ******************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_AbortReceive(const I2C_MASTER_t *const handle)
{
    /*Reset the user buffer pointer to null*/
    handle->runtime->rx_busy = false;
    handle->runtime->tx_busy = false;
    handle->runtime->rx_data = NULL;

    handle->runtime->bus_acquired = false;

    /*Disable the receive interrupts*/
    if (handle->config->rxFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
                (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
                           (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
    }
    else
    {
      XMC_USIC_CH_DisableEvent(handle->channel,
                (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE |
                (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
    }
    XMC_I2C_CH_DisableEvent(handle->channel,((uint32_t)XMC_I2C_CH_EVENT_ACK ));
	
	return(I2C_MASTER_STATUS_SUCCESS);
}
