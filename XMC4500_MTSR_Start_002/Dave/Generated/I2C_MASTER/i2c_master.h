/**
 * @file i2c_master.h
 * @date 2015-06-10
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is
 * regenerated.
 */
/**
 * @cond
 ***********************************************************************************************************************
 * I2C_MASTER v4.1.4 Configures USIC channel to transmit & receive data using I2C protocol.
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version<br>
 *
 * 2015-06-10:
 *     - AbortTransmit and AbortReceive API return type modified. <br>
 * @endcond
 *
 */

#ifndef I2C_MASTER_H
#define I2C_MASTER_H


/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include <xmc_gpio.h>
#include <xmc_i2c.h>
#if(UC_FAMILY == XMC4)
#include "CPU_CTRL_XMC4/cpu_ctrl_xmc4.h"
#else
#include "CPU_CTRL_XMC1/cpu_ctrl_xmc1.h"
#endif
#include "i2c_master_conf.h"
#include <DAVE_Common.h>

typedef void(*i2c_master_fptr_cbhandler)(void);

/*********************************************************************************************************************
 * MACROS
 ********************************************************************************************************************/
#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "I2C_MASTER requires XMC Peripheral Library v2.0.0 or higher"
#endif
/*********************************************************************************************************************
 * ENUMS
 ********************************************************************************************************************/
/**
 * @ingroup I2C_MASTER_enumerations
 * @{
 */
/**
 * Initialization status.
 */
typedef enum I2C_MASTER_STATUS
{
  I2C_MASTER_STATUS_SUCCESS = 0U,    /*!< I2C_MASTER SUCCESS */
  I2C_MASTER_STATUS_FAILURE = 1U,    /*!< I2C_MASTER FAILURE */
  I2C_MASTER_STATUS_BUSY = 2U
} I2C_MASTER_STATUS_t;

typedef enum I2C_MASTER_DIRECTION
{
  I2C_MASTER_DIRECTION_TRANSMIT = 0U,   /*!< Direction indicates transmit */
  I2C_MASTER_DIRECTION_RECEIVE = 1U     /*!< Direction indicates receive */
} I2C_MASTER_DIRECTION_t;

/**
 * @}
 */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/

/**
 * @ingroup I2C_MASTER_datastructures
 * @{
 */

/**
 * @brief Constant structure for holding the configuration parameters of I2C channel.
 */
typedef struct I2C_MASTER_CONFIG
{
   const XMC_I2C_CH_CONFIG_t *brg_config;             /*!< Basic I2C configuration from the GUI with baud*/
   i2c_master_fptr_cbhandler fptr_i2c_config;         /*!< Function pointer to configure the MUX values*/
   i2c_master_fptr_cbhandler tx_cbhandler;            /*!< Function pointer to hold the callback function pointer,
                                                           called when the transmission is complete*/
   i2c_master_fptr_cbhandler rx_cbhandler;            /*!< Function pointer to hold the callback function pointer,
                                                           called when the reception is complete*/
   i2c_master_fptr_cbhandler nack_cbhandler;          /*!< Function pointer to hold the callback function pointer,
                                                           called when nack is received*/
   i2c_master_fptr_cbhandler arbitration_cbhandler;   /*!< Function pointer to hold the callback function pointer,
                                                           called when arbitration lost is occured*/
   i2c_master_fptr_cbhandler error_cbhandler;         /*!< Function pointer to hold the callback function pointer,
                                                           called when error is detected.*/
   XMC_USIC_CH_FIFO_SIZE_t txFIFO_size;               /*!< TxFIFO size configuration*/
   XMC_USIC_CH_FIFO_SIZE_t rxFIFO_size;               /*!< RxFIFO size configuration*/

} I2C_MASTER_CONFIG_t;

/**
 * @brief Structure to hold the dynamic variables for the I2C_MASTER communication.
 */
typedef struct I2C_MASTER_RUNTIME
{
  uint8_t * tx_data;                     /*!< Pointer to the transmit data buffer*/
  uint8_t * rx_data;                     /*!< Pointer to the receive data buffer*/
  uint32_t tx_data_count;                /*!< Number of bytes of data to be transmitted*/
  volatile uint32_t tx_data_index;       /*!< Index to the byte to be transmitted next in the tx_data buffer*/
  uint32_t rx_data_count;                /*!< Number of bytes of data to be received*/
  volatile uint32_t rx_data_index;       /*!< Indicates the number of bytes currently available in the rx_data buffer*/
  volatile uint32_t direction;           /*!< Indicates TRANSMIT/RECEIVE */
  uint32_t send_stop;                    /*!< Indicates to stop the I2C */
  uint32_t send_nack;                    /*!< Indicates to send nack */
  uint8_t tx_ack_sr;                         /*!< Service request number assigned to transmit interrupt*/
  uint8_t rx_sr;                         /*!< Service request number assigned to receive interrupts*/
  volatile bool tx_busy;                 /*!< Status flag to indicate busy when a transmission is assigned*/
  volatile bool rx_busy;                 /*!< Status flag to indicate busy when a reception is assigned*/
  volatile bool bus_acquired;            /*!< flag to indicate whether bus is acquired or not */
} I2C_MASTER_RUNTIME_t;


/**
 * @brief Handler structure with pointers to dynamic and static parameters.
 */
typedef struct I2C_MASTER
{
   XMC_USIC_CH_t *channel;                    /*!< USIC channel*/
   const I2C_MASTER_CONFIG_t * const config;  /*!< I2C configuration structure pointer*/
   I2C_MASTER_RUNTIME_t * const runtime;      /*!< Pointer to the structure holding all variables,
   	                                               that can change at runtime*/
} I2C_MASTER_t;

/**
 * @}
 */

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @ingroup I2C_MASTER_apidoc
 * @{
 */

/**********************************************************************************************************************
 * API PROTOTYPES
***********************************************************************************************************************/
/**
 * @brief Get I2C_MASTER APP version.
 * @return \a DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * @code
 *  #include <DAVE.h>
 *
 *  int main(void)
 *  {
 *    DAVE_APP_VERSION_t version;
 *    DAVE_Init();
 *    version = I2C_MASTER_GetAppVersion();
 *    if(version.major != 4U)
 *    {
 *    }
 *   while(1)
 *   {}
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
DAVE_APP_VERSION_t I2C_MASTER_GetAppVersion(void);
/**
 * @brief This function initializes the I2C_MASTER APP based on user provided configuration.
 *
 * @return None
 *
 * \par<b>Description: </b><br>
 * I2C configurations like channel selection,baud rate setting,
 * FIFO configuration etc are done in this API.
 * Protocol specific interrupts can also be enabled using the I2C_MASTER_Init
 * function.
 *
 * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *   // Initializing the modules and the multiplexer
 *   DAVE_Init(); // I2C_MASTER_Init will be called from DAVE_Init()
 *   while(1)
 *   {}
 *   return 0;
 * }
 * @endcode<BR> </p>
 *
 */

I2C_MASTER_STATUS_t I2C_MASTER_Init(const I2C_MASTER_t *const handle);


/**
 * @brief  Receives the data from I2C slave device.
 * @param  handle I2C device handle of type I2C_MASTER_t*
 * @param  send_start Flag to indicate that the start condition need to be send.
 * @param  address I2C slave device address.
 * @param  data buffer to receive data.
 * @param  count The number of bytes to be received from slave.
 * @param  send_stop The flag to indicate that the stop condition need to be send.
 * @param  send_nack The flag to indicate that the NACK condition need to be send for the last byte of data.
 * @return @ref I2C_MASTER_STATUS_t Status.
 *
 * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 *
 * @code
 * #include <DAVE.h>
 * #define HMI_PCA9502_ADDRESS (0x9A)

 * #define IO_EXPANDER_ADDRESS HMI_PCA9502_ADDRESS
 * #define BYTES_TO_READ 10
 * #define BYTES_TO_TRANSMIT 10
 *
 * typedef enum PCA9502_REGADDR {
 *    IO_DIR    = 0xA << 3,
 *    IO_STATE  = 0xB << 3,
 *    IO_INTE   = 0xC << 3,
 *    IO_CTRL   = 0xE << 3
 * } PCA9502_REGADDR_t;

 * uint8_t mem_address[2];
 * volatile uint8_t tx_completion_0 = 0,rx_completion_0 = 0;
 * uint8_t data = 0x55;
 * uint8_t rx_data;
 *
 * void tx_callback_0(void)
 * {
 *   tx_completion_0 = 1;
 * }
 *
 * void rx_callback_0(void)
 * {
 *   rx_completion_0 = 1;
 * }
 *
 * int main(void)
 * {

 *  DAVE_Init();

 *  mem_address[0] = IO_STATE;//memory which need to be read from slave
 *  //Write data to IO EXPANDER
 *  I2C_MASTER_Transmit(&I2C_MASTER_0,true,IO_EXPANDER_ADDRESS,mem_address,1,false);
 *  while(tx_completion_0 == 0);
 *  tx_completion_0 = 0;
 *
 *  I2C_MASTER_Transmit(&I2C_MASTER_0,false,IO_EXPANDER_ADDRESS,&data,1,true);
 *  while(tx_completion_0 == 0);
 *  tx_completion_0 = 0;

 *  //Read data from IO EXPANDER
 *  I2C_MASTER_Transmit(&I2C_MASTER_0,true,IO_EXPANDER_ADDRESS,mem_address,1,false);
 *  while(tx_completion_0 == 0);
 *  tx_completion_0 = 0;
 *
 *  I2C_MASTER_Receive(&I2C_MASTER_0,true,IO_EXPANDER_ADDRESS,&rx_data,1,true,true);
 *  while(rx_completion_0 == 0);
 *  rx_completion_0 = 0;
 *  while(1)
 *  { }

 *  return 0;
 * }
 *
 * @endcode<BR> </p>
 *
 */
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                       uint8_t * data, const uint32_t count, bool send_stop, bool send_nack);

/**
 * @brief Transmits data to I2C slave device.
 *
 * @param  handle I2C device handle of type I2C_MASTER_t*
 * @param  send_start The flag to indicate that the start condition need to be send.
 * @param  address I2C slave device address.
 * @param  data buffer containing the data to transmit.
 * @param  size The number of bytes to be send to slave.
 * @param  send_stop The flag to indicate that the stop condition need to be send.
 *
 * @return @ref I2C_MASTER_STATUS_t Status.
 * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 *
 * @code
 * #include <DAVE.h>
 * #define HMI_PCA9502_ADDRESS (0x9A)
 * typedef enum PCA9502_REGADDR {
 *    IO_DIR    = 0xA << 3,
 *    IO_STATE  = 0xB << 3,
 *    IO_INTE   = 0xC << 3,
 *    IO_CTRL   = 0xE << 3
 * } PCA9502_REGADDR_t;
 *
 * #define IO_EXPANDER_ADDRESS HMI_PCA9502_ADDRESS

 * uint8_t tx_buffer[64] = {0x01,0x02,0x03,0x04,0x05};
 * uint8_t mem_address[2];
 * volatile uint8_t tx_completion_0 = 0,rx_completion_0 = 0;
 *
 * void tx_callback_0(void)
 * {
 *   tx_completion_0 = 1;
 * }
 *
 * int main(void)
 * {

 *  DAVE_Init();

 *  mem_address[0] = IO_STATE;//memory which need to be read from slave
 *  //Write data to IO EXPANDER
 *  I2C_MASTER_Transmit(&I2C_MASTER_0,true,IO_EXPANDER_ADDRESS,mem_address,1,false);
 *  while(tx_completion_0 == 0);
 *  tx_completion_0 = 0;
 *
 *  I2C_MASTER_Transmit(&I2C_MASTER_0,false,IO_EXPANDER_ADDRESS,tx_buffer,5,true);
 *  while(tx_completion_0 == 0);
 *  tx_completion_0 = 0;

 *  while(1)
 *  { }

 *  return 0;
 * }
 *
 * @endcode<BR> </p>
 *
 */
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
		                                uint8_t *data, const uint32_t size, bool send_stop);

/**
 * @brief Get the I2C flag status.
 *
 * @param  handle I2C device handle of type I2C_MASTER_t*
 * @param  flagtype   single or multiple flags, whose status need to be checked.
 *			 	      bitwise OR operation on elements of enum XMC_I2C_CH_STATUS_FLAG_t can be used to select multiple
 *			 	      flags.
 *
 * @return uint32_t Flag status.
 *
 * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 *
 * @code
 * #include <DAVE.h>
 *
 * #define HMI_PCA9502_ADDRESS (0x9A)
 * typedef enum PCA9502_REGADDR {
 *    IO_DIR    = 0xA << 3,
 *    IO_STATE  = 0xB << 3,
 *    IO_INTE   = 0xC << 3,
 *    IO_CTRL   = 0xE << 3
 * } PCA9502_REGADDR_t;
 * int main(void)
 * {
 *
 *  uint32_t get_flag_error = 0,clear_flag_error = 0;
 *  uint8_t i2c_data = 0;
 *
 *  DAVE_Init();
 *
 *  //Transmission flags
 *  i2c_data = IO_STATE;
 *  I2C_MASTER_Transmit(&I2C_MASTER_0,true,HMI_PCA9502_ADDRESS,&i2c_data,1,false);
 *
 *  if(!I2C_MASTER_GetFlagStatus(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION))
 *  {
 *   get_flag_error++;
 *  }
 *
 *  I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
 *  if(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION))
 *  {
 *   clear_flag_error++;
 *  }
 *  while(1)
 *  {}
 *
 *  return 0;
 * }

 * @endcode<BR> </p>
 *
 */
uint32_t I2C_MASTER_GetFlagStatus(const I2C_MASTER_t *handle, uint32_t flagtype);

/**
 * @brief Clear the I2C flag status.
 *
 * @param  handle I2C device handle of type I2C_MASTER_t*
 * @param  flagtype   single or multiple flags, whose status need to be checked.
 *                    The bitwise OR operation on elements of enum XMC_I2C_CH_STATUS_FLAG_t can be used to select
 *                    multiple flags.
 *
 * @return None <BR>
 * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 * @code
 * #include <DAVE.h>
 *
 * #define HMI_PCA9502_ADDRESS (0x9A)
 *
 * typedef enum PCA9502_REGADDR {
 *    IO_DIR    = 0xA << 3,
 *    IO_STATE  = 0xB << 3,
 *    IO_INTE   = 0xC << 3,
 *    IO_CTRL   = 0xE << 3
 * } PCA9502_REGADDR_t;
 *
 * int main(void)
 * {
 *
 *  uint32_t get_flag_error = 0,clear_flag_error = 0;
 *  uint8_t i2c_data = IO_STATE;
 *
 *  DAVE_Init();
 *
 *  //Transmission flags
 *  i2c_data = IO_STATE;
 *  I2C_MASTER_Transmit(&I2C_MASTER_0,true,HMI_PCA9502_ADDRESS,&i2c_data,1,false);
 *
 *  if(!I2C_MASTER_GetFlagStatus(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION))
 *  {
 *   get_flag_error++;
 *  }
 *
 *  I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
 *  if(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION))
 *  {
 *   clear_flag_error++;
 *  }
 *  while(1)
 *  {}
 *
 *  return 0;
 * }

 * @endcode<BR> </p>
 *
 */
void I2C_MASTER_ClearFlag(const I2C_MASTER_t *handle, uint32_t flagtype);

/*
 * Function implements the data transmission. It is called from the transmit interrupt service handler.
 * Function pushes data to the output block and releases control. It is called again when the previous data is
 * transmitted. When transmit FIFO is used, the function sets the trigger limit based on the size of data to be
 * transmitted. This makes sure that the CPU usage is optimum.
 *
 * I2C_MASTER_t * pointer to the I2C_MASTER APP instance handle
 *
 */
void I2C_MASTER_TransmitHandler(I2C_MASTER_t * const handle);

/*
 * Function implements the data reception. It is called from the receive interrupt service handler.
 * Function reads data from the receive block and updates the user's buffer. It is called again when the data is
 * received again. When receive FIFO is used, the function sets the trigger limit based on the size of data to be
 * received. This makes sure that the CPU usage is optimum.
 *
 * I2C_MASTER_t * pointer to the I2C_MASTER APP instance handle
 *
 */
void I2C_MASTER_ReceiveHandler(I2C_MASTER_t * const handle);

/*
 * Function monitors the configured protocol interrupt flags. It is called from the protocol interrupt
 * service handler.
 * Function reads the status of the USIC channel and checks for configured flags in the app UI.
 * If any callback function is provided in the app UI, it will be called when the selected flag is set.
 *
 * I2C_MASTER_t * pointer to the I2C_MASTER APP instance handle
 *
 */
void I2C_MASTER_ProtocolHandler(I2C_MASTER_t * const handle);

/**
 * @brief Aborts the ongoing data transmission.
 * @param handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
 * @return None
 *
 * \par<b>Description:</b><br>
 * If there is a transmission in progress, it will be stopped. If transmit FIFO is used,
 * the existing data will be flushed. After the transmission is stopped, user can start
 * a new transmission without delay.
 *
 * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *   #define HMI_PCA9502_ADDRESS (0x9A)
 *   #define IO_EXPANDER_ADDRESS HMI_PCA9502_ADDRESS
 *   int main(void)
 *   {
 *     I2C_MASTER_STATUS_t init_status;
 *     uint8_t Send_Data[] = "Infineon DAVE application.";
 *     uint8_t NewData[] = "New data message";
 *
 *     init_status = I2C_MASTER_Init(&I2C_MASTER_0);
 *     if(init_status == I2C_MASTER_STATUS_SUCCESS)
 *     {
 *       I2C_MASTER_Transmit(&I2C_MASTER_0, true, IO_EXPANDER_ADDRESS, Send_Data, sizeof(Send_Data), false);
 *       if(I2C_MASTER_0.dynamic->tx_busy)
 *       {
 *         init_status = I2C_MASTER_AbortTransmit(&I2C_MASTER_0);
 *         if(init_status == I2C_MASTER_STATUS_SUCCESS)
 *         {
 *           I2C_MASTER_Transmit(&I2C_MASTER_0, true, IO_EXPANDER_ADDRESS, NewData, sizeof(NewData), false);
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *   }
 * @endcode
 *
 */
I2C_MASTER_STATUS_t I2C_MASTER_AbortTransmit(const I2C_MASTER_t *const handle);

/**
* @brief Stops the active data reception request.
 * @param handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
 * @return None
 *
 * \par<b>Description:</b><br>
 * If a reception is in progress, it will be stopped. When a reception request
 * is active, user will not be able to place a new receive request till the active
 * reception is complete. This API can stop the progressing reception to make
 * a new receive request.
 *
 * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 * Example Usage:
 * @code
 *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *  #define HMI_PCA9502_ADDRESS (0x9A)
 *  #define IO_EXPANDER_ADDRESS HMI_PCA9502_ADDRESS

 *  int main(void)
 *  {
 *   I2C_MASTER_STATUS_t init_status;
 *   uint8_t Send_Data[] = "Infineon DAVE application.";
 *   uint8_t Rec_Data[64];

 *   init_status = I2C_MASTER_Init(&I2C_MASTER_0);
 *   if(init_status == I2C_MASTER_STATUS_SUCCESS)
 *   {
 *     I2C_MASTER_Transmit(&I2C_MASTER_0, true, IO_EXPANDER_ADDRESS, Send_Data, sizeof(Send_Data), false);
 *     while(I2C_MASTER_0.dynamic->tx_busy);

 *     I2C_MASTER_Receive(&I2C_MASTER_0,true,IO_EXPANDER_ADDRESS,Rec_Data,15,true,true);
 *     while(I2C_MASTER_0.dynamic->rx_data_index == 0);
 *     if(I2C_MASTER_0.dynamic->rx_data[0] == 'I')
 *     {
 *       init_status = I2C_MASTER_AbortReceive(&I2C_MASTER_0);
 *       if (init_status == I2C_MASTER_STATUS_SUCCESS)
 *       {
 *         I2C_MASTER_Transmit(&I2C_MASTER_0, true, IO_EXPANDER_ADDRESS, Rec_Data, 1, false);
 *       }
 *     }
 *   }
 *   else
 *   {
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *    return 1U;
 *  }

 * @endcode
 *
 */
I2C_MASTER_STATUS_t I2C_MASTER_AbortReceive(const I2C_MASTER_t *const handle);

/**
 *@}
 */
 
#include "i2c_master_extern.h"

#ifdef __cplusplus
}
#endif  

#endif /* I2C_MASTER_H */

